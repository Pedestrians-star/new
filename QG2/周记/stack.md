## 周记
#### 一.学习随记
1、栈的概念：本质还是一种线性表，特点是只允许在一端进行插入或删除（ “后进先出”）

2、栈的基本操作：

初始化、判栈空、进栈、出栈、读栈顶、栈销毁
注意： <u>进栈指针先移位再赋值，出栈指针先赋值再移位</u>

3、栈有两种存储结构（顺序和链式）
- i.顺序栈（类似顺序表）

  - 利用一组地址连续的存储单元 **(数组)** 存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置
  - <u>特别注意</u>:若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定位top等于-1。
```
#define MAXSIZE 50  //定义栈中元素的最大个数
typedef int ElemType;   //ElemType的类型根据实际情况而定，这里假定为int
typedef struct{
    ElemType data[MAXSIZE];
    int top;    //用于栈顶指针
}SqStack;
```
   - 共享栈 ：两个顺序栈共享一个一维数组空间；一头一尾；两个指针top0、top1
    
     - 两个指针相邻即栈满 
     - 相比一个顺序表，各函数多了一个判断栈0或栈1的参数
     - 进栈指针先移位再赋值，出栈指针先赋值再移位
      
- ii.链栈（类似链表）
  
  - 优点：多个栈共享存储空间，且没有栈满上溢的情况
  - <u>链栈 -- 实际就是链表的首节点作栈顶、头节点作栈顶指针</u>
- 分析：
  - 对比一下顺序栈与链栈,它们在时间复杂度上是一样的,均为O(1)；
  - 对于空间性能,顺序栈需要事先确定一个固定的长度,可能会存在内存空间浪费的问题,但它的优势是存取时定位很方便,而链栈则要求每个元素都有指针域,这同时也增加了一些内存开销,但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样；
  - <u>如果栈的使用过程中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果它的变化在可控范围内,建议使用顺序栈会更好一些。</u>

- 参考文章链接：https://blog.csdn.net/Real_Fool_/article/details/113852222
3、栈的应用：递归/四则运算
  - 要想让计算机具有处理我们通常的标准（中缀）表达式的能力，最重要的就是两步：

    - 将中缀表达式转化为后缀表达式（栈用来进出运算的符号）
    - 将后缀表达式进行运算得出结果（栈用来进出运算的数字）
- 规则：

    - 遇到数字就直接输出到后缀表达式中，遇到操作符就判断其优先级，并将其压入栈中。
    - 如果栈顶元素的优先级大于等于当前操作符，则先将栈顶元素弹出并输出到后缀表达式中，再将当前操作符压入栈中。
    - 如果遇到了左括号，则直接将其压入栈中，如果遇到了右括号，则弹出栈中的元素，直到遇到了左括号为止，并将这些元素输出到后缀表达式中。
    - 最后，将栈中剩余的元素依次弹出，并输出到后缀表达式中。
  
    **图文演示**查看下方参考文章链接：https://blog.csdn.net/crr411422/article/details/130306750

#### 二.一周总结

- git给github上传文件，注意代理设置
- 参考链接：https://blog.csdn.net/weixin_48430685/article/details/131685298
-    学习新东西可以先看结果“从后往前推”再理解前面，遇到难以理解的就跳过往后看，回过头来便知其所以然
- 学习新概念的方法：从抽象到形象再到具体指向
  - 用AI示例：xx是什么 -> 请用c语言写个例子 -> 思考后反问（用之前学习过的知识点进行比较）-> 一步步深入
#### 三.存在问题
- 基本理解链表、栈等概念和基本算法，但应用于四则运算计算器的代码仍需花较长时间
#### 四.下周规划
- 重温前面所学的知识，同时提前学习数据结构一章的内容，避免周末和其他事情时间冲突 